"use strict";

exports.__esModule = true;
exports.isCompilable = isCompilable;
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _outputFileSync = _interopRequireDefault(require("output-file-sync"));

var _recursiveReaddir = _interopRequireDefault(require("recursive-readdir"));

var _camelcase = _interopRequireDefault(require("camelcase"));

var _dashify = _interopRequireDefault(require("dashify"));

var _util = require("./util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const CASE = {
  KEBAB: 'kebab',
  // kebab-case
  CAMEL: 'camel',
  // camelCase
  PASCAL: 'pascal' // PascalCase

};

function transformFilename(filename, filenameCase) {
  switch (filenameCase) {
    case CASE.KEBAB:
      return (0, _dashify.default)(filename, {
        condense: true
      });

    case CASE.CAMEL:
      return (0, _camelcase.default)(filename);

    case CASE.PASCAL:
      return (0, _camelcase.default)(filename, {
        pascalCase: true
      });

    default:
      throw new Error(`Unknown --filename-case ${filenameCase}`);
  }
}

function rename(relative, ext, filenameCase) {
  const relativePath = _path.default.parse(relative);

  relativePath.ext = `.${ext}`;
  relativePath.base = null;
  relativePath.name = transformFilename(relativePath.name, filenameCase);
  return _path.default.format(relativePath);
}

const COMPILABLE_EXTENSIONS = ['.svg', '.SVG'];

function isCompilable(filename) {
  const ext = _path.default.extname(filename);

  return COMPILABLE_EXTENSIONS.includes(ext);
}

async function dirCommand(program, filenames, _ref) {
  let {
    ext = 'js',
    filenameCase = CASE.PASCAL
  } = _ref,
      options = _objectWithoutPropertiesLoose(_ref, ["ext", "filenameCase"]);

  async function write(src, relative) {
    if (!isCompilable(relative)) return false;
    relative = rename(relative, ext, filenameCase);

    const dest = _path.default.join(program.outDir, relative);

    const code = await (0, _util.convertFile)(src, options);
    (0, _outputFileSync.default)(dest, code);
    console.info(`${src} -> ${dest}`);
    return true;
  }

  async function handle(filename) {
    const stats = await (0, _util.stat)(filename);

    if (stats.isDirectory(filename)) {
      const dirname = filename;
      const files = await (0, _recursiveReaddir.default)(dirname);
      await Promise.all(files.map(async _filename => {
        const relative = _path.default.relative(dirname, _filename);

        return write(_filename, relative);
      }));
    } else {
      await write(filename, filename);
    }
  }

  await Promise.all(filenames.map(handle));
}

var _default = dirCommand;
exports.default = _default;